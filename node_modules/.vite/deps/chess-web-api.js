import {
  __commonJS
} from "./chunk-TSHM3N6P.js";

// node_modules/chess-web-api/src/utils/sort-parameters.js
var require_sort_parameters = __commonJS({
  "node_modules/chess-web-api/src/utils/sort-parameters.js"(exports, module) {
    function defaultObject(type) {
      if (type === "string") {
        return "";
      }
      if (type === "object") {
        return {};
      }
      if (type === "function") {
        const noop = () => null;
        return noop;
      }
      if (type === "array") {
        return [];
      }
      return null;
    }
    function sortParameters(types, parameters) {
      const result = [];
      for (let i = 0; i < parameters.length; i += 1) {
        if (parameters[i] !== void 0) {
          while (result.length < types.length && (typeof parameters[i] !== types[result.length] || parameters[i] instanceof Array) && (!(parameters[i] instanceof Array) || parameters[i] instanceof Array && types[result.length] !== "array")) {
            result.push(defaultObject(types[result.length]));
          }
          if (result.length < types.length) {
            result.push(parameters[i]);
          }
        }
      }
      return result;
    }
    module.exports = {
      sortParameters
    };
  }
});

// node_modules/chess-web-api/src/queue/index.js
var require_queue = __commonJS({
  "node_modules/chess-web-api/src/queue/index.js"(exports, module) {
    var { sortParameters } = require_sort_parameters();
    function queueSetup() {
      this._requests = [];
      this._running = false;
    }
    function dispatch(method, callback, parameters, options, callbackParameters, priority) {
      if (!method || typeof method !== "function") {
        throw Error("dispatch requires request function");
      }
      if (!callback || typeof callback !== "function") {
        throw Error("dispatch requires callback function");
      }
      const [_parameters, _options, _callbackParameters, _priority] = sortParameters(
        ["array", "object", "array", "number"],
        [parameters, options, callbackParameters, priority]
      );
      const request = {
        method,
        callback,
        parameters: _parameters,
        options: _options,
        priority: _priority || 1,
        callbackParameters: _callbackParameters || []
      };
      this.enqueue(request);
    }
    function enqueue(request) {
      let contain = false;
      for (let i = 0; i < this._requests.length; i += 1) {
        if (this._requests[i].priority > request.priority) {
          this._requests.splice(i, 0, request);
          contain = true;
          break;
        }
      }
      if (!contain) {
        this._requests.push(request);
      }
      if (!this._running) {
        this.startRequests();
      }
    }
    function dequeue() {
      if (this._requests.length === 0) {
        return null;
      }
      return this._requests.shift();
    }
    function clearQueue() {
      this._requests = [];
    }
    async function startRequests() {
      while (this._requests.length > 0) {
        if (!this._running) {
          this._running = true;
        }
        const request = this.dequeue();
        const { method, callback } = request;
        let error = null;
        const response = await method(...request.parameters, request.options).catch((e) => error = e);
        callback(response, error, ...request.callbackParameters);
      }
      this._running = false;
    }
    module.exports = {
      queueSetup,
      dispatch,
      enqueue,
      dequeue,
      clearQueue,
      startRequests
    };
  }
});

// node_modules/chess-web-api/src/request/base-request.js
var require_base_request = __commonJS({
  "node_modules/chess-web-api/src/request/base-request.js"(exports, module) {
    var Request = function(builder) {
      if (!builder) {
        throw new Error("No builder supplied to constructor");
      }
      this.host = builder.host;
      this.port = builder.port;
      this.scheme = builder.scheme;
      this.queryParameters = builder.queryParameters;
      this.bodyParameters = builder.bodyParameters;
      this.headers = builder.headers;
      this.path = builder.path;
    };
    Request.prototype._getter = function(key) {
      return function() {
        return this[key];
      };
    };
    Request.prototype.getHost = Request.prototype._getter("host");
    Request.prototype.getPort = Request.prototype._getter("port");
    Request.prototype.getScheme = Request.prototype._getter("scheme");
    Request.prototype.getPath = Request.prototype._getter("path");
    Request.prototype.getQueryParameters = Request.prototype._getter(
      "queryParameters"
    );
    Request.prototype.getBodyParameters = Request.prototype._getter(
      "bodyParameters"
    );
    Request.prototype.getHeaders = Request.prototype._getter("headers");
    Request.prototype.getURI = function() {
      if (!this.scheme || !this.host || !this.port) {
        throw new Error("Missing components necessary to construct URI");
      }
      let uri = `${this.scheme}://${this.host}`;
      if (this.scheme === "http" && this.port !== 80 || this.scheme === "https" && this.port !== 443) {
        uri += `:${this.port}`;
      }
      if (this.path) {
        uri += this.path;
      }
      return uri;
    };
    Request.prototype.getURL = function() {
      const uri = this.getURI();
      if (this.getQueryParameters()) {
        return uri + this.getQueryParameterString(this.getQueryParameters());
      }
      return uri;
    };
    Request.prototype.getQueryParameterString = function() {
      const queryParameters = this.getQueryParameters();
      if (queryParameters) {
        return `?${Object.keys(queryParameters).filter((key) => queryParameters[key] !== void 0).map((key) => `${key}=${queryParameters[key]}`).join("&")}`;
      }
      return "";
    };
    Request.prototype.execute = function(method, callback) {
      if (callback) {
        method(this, callback);
        return null;
      }
      const _self = this;
      return new Promise((resolve, reject) => {
        method(_self, (error, result) => {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        });
      });
    };
    var Builder = function() {
    };
    Builder.prototype._setter = function(key) {
      return function(value) {
        this[key] = value;
        return this;
      };
    };
    Builder.prototype.withHost = Builder.prototype._setter("host");
    Builder.prototype.withPort = Builder.prototype._setter("port");
    Builder.prototype.withScheme = Builder.prototype._setter("scheme");
    Builder.prototype.withPath = Builder.prototype._setter("path");
    Builder.prototype._assigner = function(key) {
      return function() {
        for (let i = 0; i < arguments.length; i += 1) {
          this[key] = this._assign(this[key], arguments[i]);
        }
        return this;
      };
    };
    Builder.prototype.withQueryParameters = Builder.prototype._assigner(
      "queryParameters"
    );
    Builder.prototype.withBodyParameters = Builder.prototype._assigner(
      "bodyParameters"
    );
    Builder.prototype.withHeaders = Builder.prototype._assigner("headers");
    Builder.prototype._assign = function(src, obj) {
      if (obj && Array.isArray(obj)) {
        return obj;
      }
      if (obj && Object.keys(obj).length > 0) {
        return Object.assign(src || {}, obj);
      }
      return src;
    };
    Builder.prototype.build = function() {
      return new Request(this);
    };
    module.exports.builder = function() {
      return new Builder();
    };
  }
});

// node_modules/chess-web-api/src/request/webapi-request.js
var require_webapi_request = __commonJS({
  "node_modules/chess-web-api/src/request/webapi-request.js"(exports, module) {
    var Request = require_base_request();
    var DEFAULT_HOST = "api.chess.com";
    var DEFAULT_PORT = 443;
    var DEFAULT_SCHEME = "https";
    module.exports.builder = function() {
      return Request.builder().withHost(DEFAULT_HOST).withPort(DEFAULT_PORT).withScheme(DEFAULT_SCHEME);
    };
  }
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports, module) {
    if (typeof module !== "undefined") {
      module.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/superagent/lib/is-object.js
var require_is_object = __commonJS({
  "node_modules/superagent/lib/is-object.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isObject(obj) {
      return obj !== null && _typeof(obj) === "object";
    }
    module.exports = isObject;
  }
});

// node_modules/superagent/lib/request-base.js
var require_request_base = __commonJS({
  "node_modules/superagent/lib/request-base.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var isObject = require_is_object();
    module.exports = RequestBase;
    function RequestBase(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in RequestBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key))
          obj[key] = RequestBase.prototype[key];
      }
      return obj;
    }
    RequestBase.prototype.clearTimeout = function() {
      clearTimeout(this._timer);
      clearTimeout(this._responseTimeoutTimer);
      clearTimeout(this._uploadTimeoutTimer);
      delete this._timer;
      delete this._responseTimeoutTimer;
      delete this._uploadTimeoutTimer;
      return this;
    };
    RequestBase.prototype.parse = function(fn) {
      this._parser = fn;
      return this;
    };
    RequestBase.prototype.responseType = function(val) {
      this._responseType = val;
      return this;
    };
    RequestBase.prototype.serialize = function(fn) {
      this._serializer = fn;
      return this;
    };
    RequestBase.prototype.timeout = function(options) {
      if (!options || _typeof(options) !== "object") {
        this._timeout = options;
        this._responseTimeout = 0;
        this._uploadTimeout = 0;
        return this;
      }
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option)) {
          switch (option) {
            case "deadline":
              this._timeout = options.deadline;
              break;
            case "response":
              this._responseTimeout = options.response;
              break;
            case "upload":
              this._uploadTimeout = options.upload;
              break;
            default:
              console.warn("Unknown timeout option", option);
          }
        }
      }
      return this;
    };
    RequestBase.prototype.retry = function(count, fn) {
      if (arguments.length === 0 || count === true)
        count = 1;
      if (count <= 0)
        count = 0;
      this._maxRetries = count;
      this._retries = 0;
      this._retryCallback = fn;
      return this;
    };
    var ERROR_CODES = ["ECONNRESET", "ETIMEDOUT", "EADDRINFO", "ESOCKETTIMEDOUT"];
    RequestBase.prototype._shouldRetry = function(err, res) {
      if (!this._maxRetries || this._retries++ >= this._maxRetries) {
        return false;
      }
      if (this._retryCallback) {
        try {
          var override = this._retryCallback(err, res);
          if (override === true)
            return true;
          if (override === false)
            return false;
        } catch (err_) {
          console.error(err_);
        }
      }
      if (res && res.status && res.status >= 500 && res.status !== 501)
        return true;
      if (err) {
        if (err.code && ERROR_CODES.includes(err.code))
          return true;
        if (err.timeout && err.code === "ECONNABORTED")
          return true;
        if (err.crossDomain)
          return true;
      }
      return false;
    };
    RequestBase.prototype._retry = function() {
      this.clearTimeout();
      if (this.req) {
        this.req = null;
        this.req = this.request();
      }
      this._aborted = false;
      this.timedout = false;
      this.timedoutError = null;
      return this._end();
    };
    RequestBase.prototype.then = function(resolve, reject) {
      var _this = this;
      if (!this._fullfilledPromise) {
        var self2 = this;
        if (this._endCalled) {
          console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
        }
        this._fullfilledPromise = new Promise(function(resolve2, reject2) {
          self2.on("abort", function() {
            if (_this._maxRetries && _this._maxRetries > _this._retries) {
              return;
            }
            if (_this.timedout && _this.timedoutError) {
              reject2(_this.timedoutError);
              return;
            }
            var err = new Error("Aborted");
            err.code = "ABORTED";
            err.status = _this.status;
            err.method = _this.method;
            err.url = _this.url;
            reject2(err);
          });
          self2.end(function(err, res) {
            if (err)
              reject2(err);
            else
              resolve2(res);
          });
        });
      }
      return this._fullfilledPromise.then(resolve, reject);
    };
    RequestBase.prototype.catch = function(cb) {
      return this.then(void 0, cb);
    };
    RequestBase.prototype.use = function(fn) {
      fn(this);
      return this;
    };
    RequestBase.prototype.ok = function(cb) {
      if (typeof cb !== "function")
        throw new Error("Callback required");
      this._okCallback = cb;
      return this;
    };
    RequestBase.prototype._isResponseOK = function(res) {
      if (!res) {
        return false;
      }
      if (this._okCallback) {
        return this._okCallback(res);
      }
      return res.status >= 200 && res.status < 300;
    };
    RequestBase.prototype.get = function(field) {
      return this._header[field.toLowerCase()];
    };
    RequestBase.prototype.getHeader = RequestBase.prototype.get;
    RequestBase.prototype.set = function(field, val) {
      if (isObject(field)) {
        for (var key in field) {
          if (Object.prototype.hasOwnProperty.call(field, key))
            this.set(key, field[key]);
        }
        return this;
      }
      this._header[field.toLowerCase()] = val;
      this.header[field] = val;
      return this;
    };
    RequestBase.prototype.unset = function(field) {
      delete this._header[field.toLowerCase()];
      delete this.header[field];
      return this;
    };
    RequestBase.prototype.field = function(name, val) {
      if (name === null || void 0 === name) {
        throw new Error(".field(name, val) name can not be empty");
      }
      if (this._data) {
        throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject(name)) {
        for (var key in name) {
          if (Object.prototype.hasOwnProperty.call(name, key))
            this.field(key, name[key]);
        }
        return this;
      }
      if (Array.isArray(val)) {
        for (var i in val) {
          if (Object.prototype.hasOwnProperty.call(val, i))
            this.field(name, val[i]);
        }
        return this;
      }
      if (val === null || void 0 === val) {
        throw new Error(".field(name, val) val can not be empty");
      }
      if (typeof val === "boolean") {
        val = String(val);
      }
      this._getFormData().append(name, val);
      return this;
    };
    RequestBase.prototype.abort = function() {
      if (this._aborted) {
        return this;
      }
      this._aborted = true;
      if (this.xhr)
        this.xhr.abort();
      if (this.req)
        this.req.abort();
      this.clearTimeout();
      this.emit("abort");
      return this;
    };
    RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
      switch (options.type) {
        case "basic":
          this.set("Authorization", "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
          break;
        case "auto":
          this.username = user;
          this.password = pass;
          break;
        case "bearer":
          this.set("Authorization", "Bearer ".concat(user));
          break;
        default:
          break;
      }
      return this;
    };
    RequestBase.prototype.withCredentials = function(on) {
      if (on === void 0)
        on = true;
      this._withCredentials = on;
      return this;
    };
    RequestBase.prototype.redirects = function(n) {
      this._maxRedirects = n;
      return this;
    };
    RequestBase.prototype.maxResponseSize = function(n) {
      if (typeof n !== "number") {
        throw new TypeError("Invalid argument");
      }
      this._maxResponseSize = n;
      return this;
    };
    RequestBase.prototype.toJSON = function() {
      return {
        method: this.method,
        url: this.url,
        data: this._data,
        headers: this._header
      };
    };
    RequestBase.prototype.send = function(data) {
      var isObj = isObject(data);
      var type = this._header["content-type"];
      if (this._formData) {
        throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObj && !this._data) {
        if (Array.isArray(data)) {
          this._data = [];
        } else if (!this._isHost(data)) {
          this._data = {};
        }
      } else if (data && this._data && this._isHost(this._data)) {
        throw new Error("Can't merge these send calls");
      }
      if (isObj && isObject(this._data)) {
        for (var key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key))
            this._data[key] = data[key];
        }
      } else if (typeof data === "string") {
        if (!type)
          this.type("form");
        type = this._header["content-type"];
        if (type === "application/x-www-form-urlencoded") {
          this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
        } else {
          this._data = (this._data || "") + data;
        }
      } else {
        this._data = data;
      }
      if (!isObj || this._isHost(data)) {
        return this;
      }
      if (!type)
        this.type("json");
      return this;
    };
    RequestBase.prototype.sortQuery = function(sort) {
      this._sort = typeof sort === "undefined" ? true : sort;
      return this;
    };
    RequestBase.prototype._finalizeQueryString = function() {
      var query = this._query.join("&");
      if (query) {
        this.url += (this.url.includes("?") ? "&" : "?") + query;
      }
      this._query.length = 0;
      if (this._sort) {
        var index = this.url.indexOf("?");
        if (index >= 0) {
          var queryArr = this.url.slice(index + 1).split("&");
          if (typeof this._sort === "function") {
            queryArr.sort(this._sort);
          } else {
            queryArr.sort();
          }
          this.url = this.url.slice(0, index) + "?" + queryArr.join("&");
        }
      }
    };
    RequestBase.prototype._appendQueryString = function() {
      console.warn("Unsupported");
    };
    RequestBase.prototype._timeoutError = function(reason, timeout, errno) {
      if (this._aborted) {
        return;
      }
      var err = new Error("".concat(reason + timeout, "ms exceeded"));
      err.timeout = timeout;
      err.code = "ECONNABORTED";
      err.errno = errno;
      this.timedout = true;
      this.timedoutError = err;
      this.abort();
      this.callback(err);
    };
    RequestBase.prototype._setTimeouts = function() {
      var self2 = this;
      if (this._timeout && !this._timer) {
        this._timer = setTimeout(function() {
          self2._timeoutError("Timeout of ", self2._timeout, "ETIME");
        }, this._timeout);
      }
      if (this._responseTimeout && !this._responseTimeoutTimer) {
        this._responseTimeoutTimer = setTimeout(function() {
          self2._timeoutError("Response timeout of ", self2._responseTimeout, "ETIMEDOUT");
        }, this._responseTimeout);
      }
    };
  }
});

// node_modules/superagent/lib/utils.js
var require_utils = __commonJS({
  "node_modules/superagent/lib/utils.js"(exports) {
    "use strict";
    exports.type = function(str) {
      return str.split(/ *; */).shift();
    };
    exports.params = function(str) {
      return str.split(/ *; */).reduce(function(obj, str2) {
        var parts = str2.split(/ *= */);
        var key = parts.shift();
        var val = parts.shift();
        if (key && val)
          obj[key] = val;
        return obj;
      }, {});
    };
    exports.parseLinks = function(str) {
      return str.split(/ *, */).reduce(function(obj, str2) {
        var parts = str2.split(/ *; */);
        var url = parts[0].slice(1, -1);
        var rel = parts[1].split(/ *= */)[1].slice(1, -1);
        obj[rel] = url;
        return obj;
      }, {});
    };
    exports.cleanHeader = function(header, changesOrigin) {
      delete header["content-type"];
      delete header["content-length"];
      delete header["transfer-encoding"];
      delete header.host;
      if (changesOrigin) {
        delete header.authorization;
        delete header.cookie;
      }
      return header;
    };
  }
});

// node_modules/superagent/lib/response-base.js
var require_response_base = __commonJS({
  "node_modules/superagent/lib/response-base.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = ResponseBase;
    function ResponseBase(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in ResponseBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key))
          obj[key] = ResponseBase.prototype[key];
      }
      return obj;
    }
    ResponseBase.prototype.get = function(field) {
      return this.header[field.toLowerCase()];
    };
    ResponseBase.prototype._setHeaderProperties = function(header) {
      var ct = header["content-type"] || "";
      this.type = utils.type(ct);
      var params = utils.params(ct);
      for (var key in params) {
        if (Object.prototype.hasOwnProperty.call(params, key))
          this[key] = params[key];
      }
      this.links = {};
      try {
        if (header.link) {
          this.links = utils.parseLinks(header.link);
        }
      } catch (_unused) {
      }
    };
    ResponseBase.prototype._setStatusProperties = function(status) {
      var type = status / 100 | 0;
      this.statusCode = status;
      this.status = this.statusCode;
      this.statusType = type;
      this.info = type === 1;
      this.ok = type === 2;
      this.redirect = type === 3;
      this.clientError = type === 4;
      this.serverError = type === 5;
      this.error = type === 4 || type === 5 ? this.toError() : false;
      this.created = status === 201;
      this.accepted = status === 202;
      this.noContent = status === 204;
      this.badRequest = status === 400;
      this.unauthorized = status === 401;
      this.notAcceptable = status === 406;
      this.forbidden = status === 403;
      this.notFound = status === 404;
      this.unprocessableEntity = status === 422;
    };
  }
});

// node_modules/superagent/lib/agent-base.js
var require_agent_base = __commonJS({
  "node_modules/superagent/lib/agent-base.js"(exports, module) {
    "use strict";
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function Agent() {
      this._defaults = [];
    }
    ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(fn) {
      Agent.prototype[fn] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this._defaults.push({
          fn,
          args
        });
        return this;
      };
    });
    Agent.prototype._setDefaults = function(req) {
      this._defaults.forEach(function(def) {
        req[def.fn].apply(req, _toConsumableArray(def.args));
      });
    };
    module.exports = Agent;
  }
});

// node_modules/superagent/lib/client.js
var require_client = __commonJS({
  "node_modules/superagent/lib/client.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var root;
    if (typeof window !== "undefined") {
      root = window;
    } else if (typeof self === "undefined") {
      console.warn("Using browser-only version of superagent in non-browser environment");
      root = void 0;
    } else {
      root = self;
    }
    var Emitter = require_component_emitter();
    var safeStringify = require_fast_safe_stringify();
    var RequestBase = require_request_base();
    var isObject = require_is_object();
    var ResponseBase = require_response_base();
    var Agent = require_agent_base();
    function noop() {
    }
    module.exports = function(method, url) {
      if (typeof url === "function") {
        return new exports.Request("GET", method).end(url);
      }
      if (arguments.length === 1) {
        return new exports.Request("GET", method);
      }
      return new exports.Request(method, url);
    };
    exports = module.exports;
    var request = exports;
    exports.Request = Request;
    request.getXHR = function() {
      if (root.XMLHttpRequest && (!root.location || root.location.protocol !== "file:" || !root.ActiveXObject)) {
        return new XMLHttpRequest();
      }
      try {
        return new ActiveXObject("Microsoft.XMLHTTP");
      } catch (_unused) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.6.0");
      } catch (_unused2) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.3.0");
      } catch (_unused3) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP");
      } catch (_unused4) {
      }
      throw new Error("Browser-only version of superagent could not find XHR");
    };
    var trim = "".trim ? function(s) {
      return s.trim();
    } : function(s) {
      return s.replace(/(^\s*|\s*$)/g, "");
    };
    function serialize(obj) {
      if (!isObject(obj))
        return obj;
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          pushEncodedKeyValuePair(pairs, key, obj[key]);
      }
      return pairs.join("&");
    }
    function pushEncodedKeyValuePair(pairs, key, val) {
      if (val === void 0)
        return;
      if (val === null) {
        pairs.push(encodeURI(key));
        return;
      }
      if (Array.isArray(val)) {
        val.forEach(function(v) {
          pushEncodedKeyValuePair(pairs, key, v);
        });
      } else if (isObject(val)) {
        for (var subkey in val) {
          if (Object.prototype.hasOwnProperty.call(val, subkey))
            pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
        }
      } else {
        pairs.push(encodeURI(key) + "=" + encodeURIComponent(val));
      }
    }
    request.serializeObject = serialize;
    function parseString(str) {
      var obj = {};
      var pairs = str.split("&");
      var pair;
      var pos;
      for (var i = 0, len = pairs.length; i < len; ++i) {
        pair = pairs[i];
        pos = pair.indexOf("=");
        if (pos === -1) {
          obj[decodeURIComponent(pair)] = "";
        } else {
          obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
        }
      }
      return obj;
    }
    request.parseString = parseString;
    request.types = {
      html: "text/html",
      json: "application/json",
      xml: "text/xml",
      urlencoded: "application/x-www-form-urlencoded",
      form: "application/x-www-form-urlencoded",
      "form-data": "application/x-www-form-urlencoded"
    };
    request.serialize = {
      "application/x-www-form-urlencoded": serialize,
      "application/json": safeStringify
    };
    request.parse = {
      "application/x-www-form-urlencoded": parseString,
      "application/json": JSON.parse
    };
    function parseHeader(str) {
      var lines = str.split(/\r?\n/);
      var fields = {};
      var index;
      var line;
      var field;
      var val;
      for (var i = 0, len = lines.length; i < len; ++i) {
        line = lines[i];
        index = line.indexOf(":");
        if (index === -1) {
          continue;
        }
        field = line.slice(0, index).toLowerCase();
        val = trim(line.slice(index + 1));
        fields[field] = val;
      }
      return fields;
    }
    function isJSON(mime) {
      return /[/+]json($|[^-\w])/.test(mime);
    }
    function Response(req) {
      this.req = req;
      this.xhr = this.req.xhr;
      this.text = this.req.method !== "HEAD" && (this.xhr.responseType === "" || this.xhr.responseType === "text") || typeof this.xhr.responseType === "undefined" ? this.xhr.responseText : null;
      this.statusText = this.req.xhr.statusText;
      var status = this.xhr.status;
      if (status === 1223) {
        status = 204;
      }
      this._setStatusProperties(status);
      this.headers = parseHeader(this.xhr.getAllResponseHeaders());
      this.header = this.headers;
      this.header["content-type"] = this.xhr.getResponseHeader("content-type");
      this._setHeaderProperties(this.header);
      if (this.text === null && req._responseType) {
        this.body = this.xhr.response;
      } else {
        this.body = this.req.method === "HEAD" ? null : this._parseBody(this.text ? this.text : this.xhr.response);
      }
    }
    ResponseBase(Response.prototype);
    Response.prototype._parseBody = function(str) {
      var parse = request.parse[this.type];
      if (this.req._parser) {
        return this.req._parser(this, str);
      }
      if (!parse && isJSON(this.type)) {
        parse = request.parse["application/json"];
      }
      return parse && str && (str.length > 0 || str instanceof Object) ? parse(str) : null;
    };
    Response.prototype.toError = function() {
      var req = this.req;
      var method = req.method;
      var url = req.url;
      var msg = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
      var err = new Error(msg);
      err.status = this.status;
      err.method = method;
      err.url = url;
      return err;
    };
    request.Response = Response;
    function Request(method, url) {
      var self2 = this;
      this._query = this._query || [];
      this.method = method;
      this.url = url;
      this.header = {};
      this._header = {};
      this.on("end", function() {
        var err = null;
        var res = null;
        try {
          res = new Response(self2);
        } catch (err_) {
          err = new Error("Parser is unable to parse the response");
          err.parse = true;
          err.original = err_;
          if (self2.xhr) {
            err.rawResponse = typeof self2.xhr.responseType === "undefined" ? self2.xhr.responseText : self2.xhr.response;
            err.status = self2.xhr.status ? self2.xhr.status : null;
            err.statusCode = err.status;
          } else {
            err.rawResponse = null;
            err.status = null;
          }
          return self2.callback(err);
        }
        self2.emit("response", res);
        var new_err;
        try {
          if (!self2._isResponseOK(res)) {
            new_err = new Error(res.statusText || res.text || "Unsuccessful HTTP response");
          }
        } catch (err_) {
          new_err = err_;
        }
        if (new_err) {
          new_err.original = err;
          new_err.response = res;
          new_err.status = res.status;
          self2.callback(new_err, res);
        } else {
          self2.callback(null, res);
        }
      });
    }
    Emitter(Request.prototype);
    RequestBase(Request.prototype);
    Request.prototype.type = function(type) {
      this.set("Content-Type", request.types[type] || type);
      return this;
    };
    Request.prototype.accept = function(type) {
      this.set("Accept", request.types[type] || type);
      return this;
    };
    Request.prototype.auth = function(user, pass, options) {
      if (arguments.length === 1)
        pass = "";
      if (_typeof(pass) === "object" && pass !== null) {
        options = pass;
        pass = "";
      }
      if (!options) {
        options = {
          type: typeof btoa === "function" ? "basic" : "auto"
        };
      }
      var encoder = function encoder2(string) {
        if (typeof btoa === "function") {
          return btoa(string);
        }
        throw new Error("Cannot use basic auth, btoa is not a function");
      };
      return this._auth(user, pass, options, encoder);
    };
    Request.prototype.query = function(val) {
      if (typeof val !== "string")
        val = serialize(val);
      if (val)
        this._query.push(val);
      return this;
    };
    Request.prototype.attach = function(field, file, options) {
      if (file) {
        if (this._data) {
          throw new Error("superagent can't mix .send() and .attach()");
        }
        this._getFormData().append(field, file, options || file.name);
      }
      return this;
    };
    Request.prototype._getFormData = function() {
      if (!this._formData) {
        this._formData = new root.FormData();
      }
      return this._formData;
    };
    Request.prototype.callback = function(err, res) {
      if (this._shouldRetry(err, res)) {
        return this._retry();
      }
      var fn = this._callback;
      this.clearTimeout();
      if (err) {
        if (this._maxRetries)
          err.retries = this._retries - 1;
        this.emit("error", err);
      }
      fn(err, res);
    };
    Request.prototype.crossDomainError = function() {
      var err = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
      err.crossDomain = true;
      err.status = this.status;
      err.method = this.method;
      err.url = this.url;
      this.callback(err);
    };
    Request.prototype.agent = function() {
      console.warn("This is not supported in browser version of superagent");
      return this;
    };
    Request.prototype.ca = Request.prototype.agent;
    Request.prototype.buffer = Request.prototype.ca;
    Request.prototype.write = function() {
      throw new Error("Streaming is not supported in browser version of superagent");
    };
    Request.prototype.pipe = Request.prototype.write;
    Request.prototype._isHost = function(obj) {
      return obj && _typeof(obj) === "object" && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== "[object Object]";
    };
    Request.prototype.end = function(fn) {
      if (this._endCalled) {
        console.warn("Warning: .end() was called twice. This is not supported in superagent");
      }
      this._endCalled = true;
      this._callback = fn || noop;
      this._finalizeQueryString();
      this._end();
    };
    Request.prototype._setUploadTimeout = function() {
      var self2 = this;
      if (this._uploadTimeout && !this._uploadTimeoutTimer) {
        this._uploadTimeoutTimer = setTimeout(function() {
          self2._timeoutError("Upload timeout of ", self2._uploadTimeout, "ETIMEDOUT");
        }, this._uploadTimeout);
      }
    };
    Request.prototype._end = function() {
      if (this._aborted)
        return this.callback(new Error("The request has been aborted even before .end() was called"));
      var self2 = this;
      this.xhr = request.getXHR();
      var xhr = this.xhr;
      var data = this._formData || this._data;
      this._setTimeouts();
      xhr.onreadystatechange = function() {
        var readyState = xhr.readyState;
        if (readyState >= 2 && self2._responseTimeoutTimer) {
          clearTimeout(self2._responseTimeoutTimer);
        }
        if (readyState !== 4) {
          return;
        }
        var status;
        try {
          status = xhr.status;
        } catch (_unused5) {
          status = 0;
        }
        if (!status) {
          if (self2.timedout || self2._aborted)
            return;
          return self2.crossDomainError();
        }
        self2.emit("end");
      };
      var handleProgress = function handleProgress2(direction, e) {
        if (e.total > 0) {
          e.percent = e.loaded / e.total * 100;
          if (e.percent === 100) {
            clearTimeout(self2._uploadTimeoutTimer);
          }
        }
        e.direction = direction;
        self2.emit("progress", e);
      };
      if (this.hasListeners("progress")) {
        try {
          xhr.addEventListener("progress", handleProgress.bind(null, "download"));
          if (xhr.upload) {
            xhr.upload.addEventListener("progress", handleProgress.bind(null, "upload"));
          }
        } catch (_unused6) {
        }
      }
      if (xhr.upload) {
        this._setUploadTimeout();
      }
      try {
        if (this.username && this.password) {
          xhr.open(this.method, this.url, true, this.username, this.password);
        } else {
          xhr.open(this.method, this.url, true);
        }
      } catch (err) {
        return this.callback(err);
      }
      if (this._withCredentials)
        xhr.withCredentials = true;
      if (!this._formData && this.method !== "GET" && this.method !== "HEAD" && typeof data !== "string" && !this._isHost(data)) {
        var contentType = this._header["content-type"];
        var _serialize = this._serializer || request.serialize[contentType ? contentType.split(";")[0] : ""];
        if (!_serialize && isJSON(contentType)) {
          _serialize = request.serialize["application/json"];
        }
        if (_serialize)
          data = _serialize(data);
      }
      for (var field in this.header) {
        if (this.header[field] === null)
          continue;
        if (Object.prototype.hasOwnProperty.call(this.header, field))
          xhr.setRequestHeader(field, this.header[field]);
      }
      if (this._responseType) {
        xhr.responseType = this._responseType;
      }
      this.emit("request", this);
      xhr.send(typeof data === "undefined" ? null : data);
    };
    request.agent = function() {
      return new Agent();
    };
    ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
      Agent.prototype[method.toLowerCase()] = function(url, fn) {
        var req = new request.Request(method, url);
        this._setDefaults(req);
        if (fn) {
          req.end(fn);
        }
        return req;
      };
    });
    Agent.prototype.del = Agent.prototype.delete;
    request.get = function(url, data, fn) {
      var req = request("GET", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.query(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.head = function(url, data, fn) {
      var req = request("HEAD", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.query(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.options = function(url, data, fn) {
      var req = request("OPTIONS", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    function del(url, data, fn) {
      var req = request("DELETE", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    }
    request.del = del;
    request.delete = del;
    request.patch = function(url, data, fn) {
      var req = request("PATCH", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.post = function(url, data, fn) {
      var req = request("POST", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.put = function(url, data, fn) {
      var req = request("PUT", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
  }
});

// node_modules/chess-web-api/src/request/webapi-error.js
var require_webapi_error = __commonJS({
  "node_modules/chess-web-api/src/request/webapi-error.js"(exports, module) {
    function WebapiError(message, statusCode) {
      this.name = "WebapiError";
      this.message = message || "";
      this.statusCode = statusCode;
    }
    WebapiError.prototype = Error.prototype;
    module.exports = WebapiError;
  }
});

// node_modules/chess-web-api/src/request/http-manager.js
var require_http_manager = __commonJS({
  "node_modules/chess-web-api/src/request/http-manager.js"(exports, module) {
    var superagent = require_client();
    var WebApiError = require_webapi_error();
    var HttpManager = {};
    var _getParametersFromRequest = function(request) {
      const options = {};
      if (request.getQueryParameters()) {
        options.query = request.getQueryParameters();
      }
      if (request.getHeaders() && request.getHeaders()["Content-Type"] === "application/json") {
        options.data = JSON.stringify(request.getBodyParameters());
      } else if (request.getBodyParameters()) {
        options.data = request.getBodyParameters();
      }
      if (request.getHeaders()) {
        options.headers = request.getHeaders();
      }
      return options;
    };
    var _getErrorObject = function(defaultMessage, err) {
      let errorObject;
      if (typeof err.error === "object" && typeof err.error.message === "string") {
        errorObject = new WebApiError(err.error.message, err.error.status);
      } else if (typeof err.error === "string") {
        errorObject = new WebApiError(`${err.error}: ${err.error_description}`);
      } else if (typeof err === "string") {
        try {
          const parsedError = JSON.parse(err);
          errorObject = new WebApiError(
            parsedError.error.message,
            parsedError.error.status
          );
        } catch (error) {
        }
      }
      if (!errorObject) {
        errorObject = new WebApiError(`${defaultMessage}: ${JSON.stringify(err)}`);
      }
      return errorObject;
    };
    HttpManager._makeRequest = function(method, options, uri, callback) {
      const req = method.bind(superagent)(uri);
      if (options.query) {
        req.query(options.query);
      }
      if (options.data && (!options.headers || options.headers["Content-Type"] !== "application/json")) {
        req.type("form");
        req.send(options.data);
      } else if (options.data) {
        req.send(options.data);
      }
      if (options.headers) {
        req.set(options.headers);
      }
      req.end((err, response) => {
        if (err) {
          const errorObject = _getErrorObject("Request error", {
            error: err
          });
          return callback(errorObject);
        }
        return callback(null, {
          body: response.body,
          headers: response.headers,
          statusCode: response.statusCode
        });
      });
    };
    HttpManager.get = function(request, callback) {
      const options = _getParametersFromRequest(request);
      const method = superagent.get;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    HttpManager.post = function(request, callback) {
      const options = _getParametersFromRequest(request);
      const method = superagent.post;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    HttpManager.del = function(request, callback) {
      const options = _getParametersFromRequest(request);
      const method = superagent.del;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    HttpManager.put = function(request, callback) {
      const options = _getParametersFromRequest(request);
      const method = superagent.put;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    module.exports = HttpManager;
  }
});

// node_modules/chess-web-api/src/endpoints/player-data.js
var require_player_data = __commonJS({
  "node_modules/chess-web-api/src/endpoints/player-data.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getPlayer(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerStats(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}/stats`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerOnline(username, options, callback, headers) {
      return new Error("This endpoint was removed by Chess.com, please see https://github.com/andyruwruw/chess-web-api/tree/master#getplayeronlineusername-options-callback");
    }
    function getPlayerCurrentDailyChess(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}/games`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerToMoveDailyChess(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}/games/to-move`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerMonthlyArchives(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}/games/archives`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerCompleteMonthlyArchives(username, year, month, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      let _month;
      if (typeof month === "number" && month < 10 || typeof month === "string" && month.length === 1) {
        _month = `0${month}`;
      } else {
        _month = `${month}`;
      }
      return WebApiRequest.builder().withPath(`/pub/player/${username}/games/${year}/${_month}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerMultiGamePGN(username, year, month, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      let _month;
      if (typeof month === "number" && month < 10 || typeof month === "string" && month.length === 1) {
        _month = `0${month}`;
      } else {
        _month = `${month}`;
      }
      return WebApiRequest.builder().withPath(`/pub/player/${username}/games/${year}/${_month}/pgn`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerClubs(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}/clubs`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerMatches(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}/matches`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getPlayerTournaments(username, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/player/${username}/tournaments`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getTitledPlayers(titleAbbrev, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/titled/${titleAbbrev}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getPlayer,
      getPlayerStats,
      getPlayerOnline,
      getPlayerCurrentDailyChess,
      getPlayerToMoveDailyChess,
      getPlayerMonthlyArchives,
      getPlayerCompleteMonthlyArchives,
      getPlayerMultiGamePGN,
      getPlayerClubs,
      getPlayerMatches,
      getPlayerTournaments,
      getTitledPlayers
    };
  }
});

// node_modules/chess-web-api/src/endpoints/clubs.js
var require_clubs = __commonJS({
  "node_modules/chess-web-api/src/endpoints/clubs.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getClub(urlID, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/club/${urlID}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getClubMembers(urlID, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/club/${urlID}/members`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getClubMatches(urlID, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/club/${urlID}/matches`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getClub,
      getClubMembers,
      getClubMatches
    };
  }
});

// node_modules/chess-web-api/src/endpoints/tournaments.js
var require_tournaments = __commonJS({
  "node_modules/chess-web-api/src/endpoints/tournaments.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getTournament(urlID, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/tournament/${urlID}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getTournamentRound(urlID, round, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/tournament/${urlID}/${round}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getTournamentRoundGroup(urlID, round, group, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/tournament/${urlID}/${round}/${group}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getTournament,
      getTournamentRound,
      getTournamentRoundGroup
    };
  }
});

// node_modules/chess-web-api/src/endpoints/team-matches.js
var require_team_matches = __commonJS({
  "node_modules/chess-web-api/src/endpoints/team-matches.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getTeamMatch(id, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/match/${id}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getTeamMatchBoard(id, board, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/match/${id}/${board}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getTeamLiveMatch(id, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/match/live/${id}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getTeamLiveMatchBoard(id, board, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/match/live/${id}/${board}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getTeamMatch,
      getTeamMatchBoard,
      getTeamLiveMatch,
      getTeamLiveMatchBoard
    };
  }
});

// node_modules/chess-web-api/src/endpoints/countries.js
var require_countries = __commonJS({
  "node_modules/chess-web-api/src/endpoints/countries.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getCountry(iso, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/country/${iso}`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getCountryPlayers(iso, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/country/${iso}/players`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getCountryClubs(iso, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath(`/pub/country/${iso}/clubs`).withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getCountry,
      getCountryPlayers,
      getCountryClubs
    };
  }
});

// node_modules/chess-web-api/src/endpoints/puzzles.js
var require_puzzles = __commonJS({
  "node_modules/chess-web-api/src/endpoints/puzzles.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getDailyPuzzle(options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath("/pub/puzzle").withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    function getDailyPuzzleRandom(options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath("/pub/puzzle/random").withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getDailyPuzzle,
      getDailyPuzzleRandom
    };
  }
});

// node_modules/chess-web-api/src/endpoints/streamers.js
var require_streamers = __commonJS({
  "node_modules/chess-web-api/src/endpoints/streamers.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getStreamers(options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath("/pub/streamers").withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getStreamers
    };
  }
});

// node_modules/chess-web-api/src/endpoints/leaderboards.js
var require_leaderboards = __commonJS({
  "node_modules/chess-web-api/src/endpoints/leaderboards.js"(exports, module) {
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var { sortParameters } = require_sort_parameters();
    function getLeaderboards(options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      return WebApiRequest.builder().withPath("/pub/leaderboards").withQueryParameters(_options).withHeaders(_headers).build().execute(HttpManager.get, _callback);
    }
    module.exports = {
      getLeaderboards
    };
  }
});

// node_modules/chess-web-api/node_modules/chess.js/chess.js
var require_chess = __commonJS({
  "node_modules/chess-web-api/node_modules/chess.js/chess.js"(exports) {
    var Chess = function(fen) {
      var BLACK = "b";
      var WHITE = "w";
      var EMPTY = -1;
      var PAWN = "p";
      var KNIGHT = "n";
      var BISHOP = "b";
      var ROOK = "r";
      var QUEEN = "q";
      var KING = "k";
      var SYMBOLS = "pnbrqkPNBRQK";
      var DEFAULT_POSITION = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
      var POSSIBLE_RESULTS = ["1-0", "0-1", "1/2-1/2", "*"];
      var PAWN_OFFSETS = {
        b: [16, 32, 17, 15],
        w: [-16, -32, -17, -15]
      };
      var PIECE_OFFSETS = {
        n: [-18, -33, -31, -14, 18, 33, 31, 14],
        b: [-17, -15, 17, 15],
        r: [-16, 1, 16, -1],
        q: [-17, -16, -15, 1, 17, 16, 15, -1],
        k: [-17, -16, -15, 1, 17, 16, 15, -1]
      };
      var ATTACKS = [
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        24,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        2,
        24,
        2,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        53,
        56,
        53,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        24,
        24,
        24,
        56,
        0,
        56,
        24,
        24,
        24,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        53,
        56,
        53,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        2,
        24,
        2,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        24,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        20
      ];
      var RAYS = [
        17,
        0,
        0,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        0,
        0,
        15,
        0,
        0,
        17,
        0,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        17,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        0,
        0,
        16,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        0,
        16,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        16,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        -16,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        -16,
        0,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        -16,
        0,
        0,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        0,
        -17,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        0,
        0,
        -17,
        0,
        0,
        -15,
        0,
        0,
        0,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        0,
        0,
        0,
        -17
      ];
      var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };
      var FLAGS = {
        NORMAL: "n",
        CAPTURE: "c",
        BIG_PAWN: "b",
        EP_CAPTURE: "e",
        PROMOTION: "p",
        KSIDE_CASTLE: "k",
        QSIDE_CASTLE: "q"
      };
      var BITS = {
        NORMAL: 1,
        CAPTURE: 2,
        BIG_PAWN: 4,
        EP_CAPTURE: 8,
        PROMOTION: 16,
        KSIDE_CASTLE: 32,
        QSIDE_CASTLE: 64
      };
      var RANK_1 = 7;
      var RANK_2 = 6;
      var RANK_3 = 5;
      var RANK_4 = 4;
      var RANK_5 = 3;
      var RANK_6 = 2;
      var RANK_7 = 1;
      var RANK_8 = 0;
      var SQUARES = {
        a8: 0,
        b8: 1,
        c8: 2,
        d8: 3,
        e8: 4,
        f8: 5,
        g8: 6,
        h8: 7,
        a7: 16,
        b7: 17,
        c7: 18,
        d7: 19,
        e7: 20,
        f7: 21,
        g7: 22,
        h7: 23,
        a6: 32,
        b6: 33,
        c6: 34,
        d6: 35,
        e6: 36,
        f6: 37,
        g6: 38,
        h6: 39,
        a5: 48,
        b5: 49,
        c5: 50,
        d5: 51,
        e5: 52,
        f5: 53,
        g5: 54,
        h5: 55,
        a4: 64,
        b4: 65,
        c4: 66,
        d4: 67,
        e4: 68,
        f4: 69,
        g4: 70,
        h4: 71,
        a3: 80,
        b3: 81,
        c3: 82,
        d3: 83,
        e3: 84,
        f3: 85,
        g3: 86,
        h3: 87,
        a2: 96,
        b2: 97,
        c2: 98,
        d2: 99,
        e2: 100,
        f2: 101,
        g2: 102,
        h2: 103,
        a1: 112,
        b1: 113,
        c1: 114,
        d1: 115,
        e1: 116,
        f1: 117,
        g1: 118,
        h1: 119
      };
      var ROOKS = {
        w: [
          { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },
          { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE }
        ],
        b: [
          { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },
          { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE }
        ]
      };
      var board = new Array(128);
      var kings = { w: EMPTY, b: EMPTY };
      var turn = WHITE;
      var castling = { w: 0, b: 0 };
      var ep_square = EMPTY;
      var half_moves = 0;
      var move_number = 1;
      var history = [];
      var header = {};
      var comments = {};
      if (typeof fen === "undefined") {
        load(DEFAULT_POSITION);
      } else {
        load(fen);
      }
      function clear(keep_headers) {
        if (typeof keep_headers === "undefined") {
          keep_headers = false;
        }
        board = new Array(128);
        kings = { w: EMPTY, b: EMPTY };
        turn = WHITE;
        castling = { w: 0, b: 0 };
        ep_square = EMPTY;
        half_moves = 0;
        move_number = 1;
        history = [];
        if (!keep_headers)
          header = {};
        comments = {};
        update_setup(generate_fen());
      }
      function prune_comments() {
        var reversed_history = [];
        var current_comments = {};
        var copy_comment = function(fen2) {
          if (fen2 in comments) {
            current_comments[fen2] = comments[fen2];
          }
        };
        while (history.length > 0) {
          reversed_history.push(undo_move());
        }
        copy_comment(generate_fen());
        while (reversed_history.length > 0) {
          make_move(reversed_history.pop());
          copy_comment(generate_fen());
        }
        comments = current_comments;
      }
      function reset() {
        load(DEFAULT_POSITION);
      }
      function load(fen2, keep_headers) {
        if (typeof keep_headers === "undefined") {
          keep_headers = false;
        }
        var tokens = fen2.split(/\s+/);
        var position = tokens[0];
        var square = 0;
        if (!validate_fen(fen2).valid) {
          return false;
        }
        clear(keep_headers);
        for (var i = 0; i < position.length; i++) {
          var piece = position.charAt(i);
          if (piece === "/") {
            square += 8;
          } else if (is_digit(piece)) {
            square += parseInt(piece, 10);
          } else {
            var color = piece < "a" ? WHITE : BLACK;
            put({ type: piece.toLowerCase(), color }, algebraic(square));
            square++;
          }
        }
        turn = tokens[1];
        if (tokens[2].indexOf("K") > -1) {
          castling.w |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf("Q") > -1) {
          castling.w |= BITS.QSIDE_CASTLE;
        }
        if (tokens[2].indexOf("k") > -1) {
          castling.b |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf("q") > -1) {
          castling.b |= BITS.QSIDE_CASTLE;
        }
        ep_square = tokens[3] === "-" ? EMPTY : SQUARES[tokens[3]];
        half_moves = parseInt(tokens[4], 10);
        move_number = parseInt(tokens[5], 10);
        update_setup(generate_fen());
        return true;
      }
      function validate_fen(fen2) {
        var errors = {
          0: "No errors.",
          1: "FEN string must contain six space-delimited fields.",
          2: "6th field (move number) must be a positive integer.",
          3: "5th field (half move counter) must be a non-negative integer.",
          4: "4th field (en-passant square) is invalid.",
          5: "3rd field (castling availability) is invalid.",
          6: "2nd field (side to move) is invalid.",
          7: "1st field (piece positions) does not contain 8 '/'-delimited rows.",
          8: "1st field (piece positions) is invalid [consecutive numbers].",
          9: "1st field (piece positions) is invalid [invalid piece].",
          10: "1st field (piece positions) is invalid [row too large].",
          11: "Illegal en-passant square"
        };
        var tokens = fen2.split(/\s+/);
        if (tokens.length !== 6) {
          return { valid: false, error_number: 1, error: errors[1] };
        }
        if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {
          return { valid: false, error_number: 2, error: errors[2] };
        }
        if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {
          return { valid: false, error_number: 3, error: errors[3] };
        }
        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
          return { valid: false, error_number: 4, error: errors[4] };
        }
        if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {
          return { valid: false, error_number: 5, error: errors[5] };
        }
        if (!/^(w|b)$/.test(tokens[1])) {
          return { valid: false, error_number: 6, error: errors[6] };
        }
        var rows = tokens[0].split("/");
        if (rows.length !== 8) {
          return { valid: false, error_number: 7, error: errors[7] };
        }
        for (var i = 0; i < rows.length; i++) {
          var sum_fields = 0;
          var previous_was_number = false;
          for (var k = 0; k < rows[i].length; k++) {
            if (!isNaN(rows[i][k])) {
              if (previous_was_number) {
                return { valid: false, error_number: 8, error: errors[8] };
              }
              sum_fields += parseInt(rows[i][k], 10);
              previous_was_number = true;
            } else {
              if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {
                return { valid: false, error_number: 9, error: errors[9] };
              }
              sum_fields += 1;
              previous_was_number = false;
            }
          }
          if (sum_fields !== 8) {
            return { valid: false, error_number: 10, error: errors[10] };
          }
        }
        if (tokens[3][1] == "3" && tokens[1] == "w" || tokens[3][1] == "6" && tokens[1] == "b") {
          return { valid: false, error_number: 11, error: errors[11] };
        }
        return { valid: true, error_number: 0, error: errors[0] };
      }
      function generate_fen() {
        var empty = 0;
        var fen2 = "";
        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
          if (board[i] == null) {
            empty++;
          } else {
            if (empty > 0) {
              fen2 += empty;
              empty = 0;
            }
            var color = board[i].color;
            var piece = board[i].type;
            fen2 += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
          }
          if (i + 1 & 136) {
            if (empty > 0) {
              fen2 += empty;
            }
            if (i !== SQUARES.h1) {
              fen2 += "/";
            }
            empty = 0;
            i += 8;
          }
        }
        var cflags = "";
        if (castling[WHITE] & BITS.KSIDE_CASTLE) {
          cflags += "K";
        }
        if (castling[WHITE] & BITS.QSIDE_CASTLE) {
          cflags += "Q";
        }
        if (castling[BLACK] & BITS.KSIDE_CASTLE) {
          cflags += "k";
        }
        if (castling[BLACK] & BITS.QSIDE_CASTLE) {
          cflags += "q";
        }
        cflags = cflags || "-";
        var epflags = ep_square === EMPTY ? "-" : algebraic(ep_square);
        return [fen2, turn, cflags, epflags, half_moves, move_number].join(" ");
      }
      function set_header(args) {
        for (var i = 0; i < args.length; i += 2) {
          if (typeof args[i] === "string" && typeof args[i + 1] === "string") {
            header[args[i]] = args[i + 1];
          }
        }
        return header;
      }
      function update_setup(fen2) {
        if (history.length > 0)
          return;
        if (fen2 !== DEFAULT_POSITION) {
          header["SetUp"] = "1";
          header["FEN"] = fen2;
        } else {
          delete header["SetUp"];
          delete header["FEN"];
        }
      }
      function get(square) {
        var piece = board[SQUARES[square]];
        return piece ? { type: piece.type, color: piece.color } : null;
      }
      function put(piece, square) {
        if (!("type" in piece && "color" in piece)) {
          return false;
        }
        if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {
          return false;
        }
        if (!(square in SQUARES)) {
          return false;
        }
        var sq = SQUARES[square];
        if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {
          return false;
        }
        board[sq] = { type: piece.type, color: piece.color };
        if (piece.type === KING) {
          kings[piece.color] = sq;
        }
        update_setup(generate_fen());
        return true;
      }
      function remove(square) {
        var piece = get(square);
        board[SQUARES[square]] = null;
        if (piece && piece.type === KING) {
          kings[piece.color] = EMPTY;
        }
        update_setup(generate_fen());
        return piece;
      }
      function build_move(board2, from, to, flags, promotion) {
        var move = {
          color: turn,
          from,
          to,
          flags,
          piece: board2[from].type
        };
        if (promotion) {
          move.flags |= BITS.PROMOTION;
          move.promotion = promotion;
        }
        if (board2[to]) {
          move.captured = board2[to].type;
        } else if (flags & BITS.EP_CAPTURE) {
          move.captured = PAWN;
        }
        return move;
      }
      function generate_moves(options) {
        function add_move(board2, moves2, from, to, flags) {
          if (board2[from].type === PAWN && (rank(to) === RANK_8 || rank(to) === RANK_1)) {
            var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];
            for (var i2 = 0, len2 = pieces.length; i2 < len2; i2++) {
              moves2.push(build_move(board2, from, to, flags, pieces[i2]));
            }
          } else {
            moves2.push(build_move(board2, from, to, flags));
          }
        }
        var moves = [];
        var us = turn;
        var them = swap_color(us);
        var second_rank = { b: RANK_7, w: RANK_2 };
        var first_sq = SQUARES.a8;
        var last_sq = SQUARES.h1;
        var single_square = false;
        var legal = typeof options !== "undefined" && "legal" in options ? options.legal : true;
        if (typeof options !== "undefined" && "square" in options) {
          if (options.square in SQUARES) {
            first_sq = last_sq = SQUARES[options.square];
            single_square = true;
          } else {
            return [];
          }
        }
        for (var i = first_sq; i <= last_sq; i++) {
          if (i & 136) {
            i += 7;
            continue;
          }
          var piece = board[i];
          if (piece == null || piece.color !== us) {
            continue;
          }
          if (piece.type === PAWN) {
            var square = i + PAWN_OFFSETS[us][0];
            if (board[square] == null) {
              add_move(board, moves, i, square, BITS.NORMAL);
              var square = i + PAWN_OFFSETS[us][1];
              if (second_rank[us] === rank(i) && board[square] == null) {
                add_move(board, moves, i, square, BITS.BIG_PAWN);
              }
            }
            for (j = 2; j < 4; j++) {
              var square = i + PAWN_OFFSETS[us][j];
              if (square & 136)
                continue;
              if (board[square] != null && board[square].color === them) {
                add_move(board, moves, i, square, BITS.CAPTURE);
              } else if (square === ep_square) {
                add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);
              }
            }
          } else {
            for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {
              var offset = PIECE_OFFSETS[piece.type][j];
              var square = i;
              while (true) {
                square += offset;
                if (square & 136)
                  break;
                if (board[square] == null) {
                  add_move(board, moves, i, square, BITS.NORMAL);
                } else {
                  if (board[square].color === us)
                    break;
                  add_move(board, moves, i, square, BITS.CAPTURE);
                  break;
                }
                if (piece.type === "n" || piece.type === "k")
                  break;
              }
            }
          }
        }
        if (!single_square || last_sq === kings[us]) {
          if (castling[us] & BITS.KSIDE_CASTLE) {
            var castling_from = kings[us];
            var castling_to = castling_from + 2;
            if (board[castling_from + 1] == null && board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) {
              add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);
            }
          }
          if (castling[us] & BITS.QSIDE_CASTLE) {
            var castling_from = kings[us];
            var castling_to = castling_from - 2;
            if (board[castling_from - 1] == null && board[castling_from - 2] == null && board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) {
              add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);
            }
          }
        }
        if (!legal) {
          return moves;
        }
        var legal_moves = [];
        for (var i = 0, len = moves.length; i < len; i++) {
          make_move(moves[i]);
          if (!king_attacked(us)) {
            legal_moves.push(moves[i]);
          }
          undo_move();
        }
        return legal_moves;
      }
      function move_to_san(move, sloppy) {
        var output = "";
        if (move.flags & BITS.KSIDE_CASTLE) {
          output = "O-O";
        } else if (move.flags & BITS.QSIDE_CASTLE) {
          output = "O-O-O";
        } else {
          var disambiguator = get_disambiguator(move, sloppy);
          if (move.piece !== PAWN) {
            output += move.piece.toUpperCase() + disambiguator;
          }
          if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
            if (move.piece === PAWN) {
              output += algebraic(move.from)[0];
            }
            output += "x";
          }
          output += algebraic(move.to);
          if (move.flags & BITS.PROMOTION) {
            output += "=" + move.promotion.toUpperCase();
          }
        }
        make_move(move);
        if (in_check()) {
          if (in_checkmate()) {
            output += "#";
          } else {
            output += "+";
          }
        }
        undo_move();
        return output;
      }
      function stripped_san(move) {
        return move.replace(/=/, "").replace(/[+#]?[?!]*$/, "");
      }
      function attacked(color, square) {
        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
          if (i & 136) {
            i += 7;
            continue;
          }
          if (board[i] == null || board[i].color !== color)
            continue;
          var piece = board[i];
          var difference = i - square;
          var index = difference + 119;
          if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {
            if (piece.type === PAWN) {
              if (difference > 0) {
                if (piece.color === WHITE)
                  return true;
              } else {
                if (piece.color === BLACK)
                  return true;
              }
              continue;
            }
            if (piece.type === "n" || piece.type === "k")
              return true;
            var offset = RAYS[index];
            var j = i + offset;
            var blocked = false;
            while (j !== square) {
              if (board[j] != null) {
                blocked = true;
                break;
              }
              j += offset;
            }
            if (!blocked)
              return true;
          }
        }
        return false;
      }
      function king_attacked(color) {
        return attacked(swap_color(color), kings[color]);
      }
      function in_check() {
        return king_attacked(turn);
      }
      function in_checkmate() {
        return in_check() && generate_moves().length === 0;
      }
      function in_stalemate() {
        return !in_check() && generate_moves().length === 0;
      }
      function insufficient_material() {
        var pieces = {};
        var bishops = [];
        var num_pieces = 0;
        var sq_color = 0;
        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
          sq_color = (sq_color + 1) % 2;
          if (i & 136) {
            i += 7;
            continue;
          }
          var piece = board[i];
          if (piece) {
            pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;
            if (piece.type === BISHOP) {
              bishops.push(sq_color);
            }
            num_pieces++;
          }
        }
        if (num_pieces === 2) {
          return true;
        } else if (
          /* k vs. kn .... or .... k vs. kb */
          num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)
        ) {
          return true;
        } else if (num_pieces === pieces[BISHOP] + 2) {
          var sum = 0;
          var len = bishops.length;
          for (var i = 0; i < len; i++) {
            sum += bishops[i];
          }
          if (sum === 0 || sum === len) {
            return true;
          }
        }
        return false;
      }
      function in_threefold_repetition() {
        var moves = [];
        var positions = {};
        var repetition = false;
        while (true) {
          var move = undo_move();
          if (!move)
            break;
          moves.push(move);
        }
        while (true) {
          var fen2 = generate_fen().split(" ").slice(0, 4).join(" ");
          positions[fen2] = fen2 in positions ? positions[fen2] + 1 : 1;
          if (positions[fen2] >= 3) {
            repetition = true;
          }
          if (!moves.length) {
            break;
          }
          make_move(moves.pop());
        }
        return repetition;
      }
      function push(move) {
        history.push({
          move,
          kings: { b: kings.b, w: kings.w },
          turn,
          castling: { b: castling.b, w: castling.w },
          ep_square,
          half_moves,
          move_number
        });
      }
      function make_move(move) {
        var us = turn;
        var them = swap_color(us);
        push(move);
        board[move.to] = board[move.from];
        board[move.from] = null;
        if (move.flags & BITS.EP_CAPTURE) {
          if (turn === BLACK) {
            board[move.to - 16] = null;
          } else {
            board[move.to + 16] = null;
          }
        }
        if (move.flags & BITS.PROMOTION) {
          board[move.to] = { type: move.promotion, color: us };
        }
        if (board[move.to].type === KING) {
          kings[board[move.to].color] = move.to;
          if (move.flags & BITS.KSIDE_CASTLE) {
            var castling_to = move.to - 1;
            var castling_from = move.to + 1;
            board[castling_to] = board[castling_from];
            board[castling_from] = null;
          } else if (move.flags & BITS.QSIDE_CASTLE) {
            var castling_to = move.to + 1;
            var castling_from = move.to - 2;
            board[castling_to] = board[castling_from];
            board[castling_from] = null;
          }
          castling[us] = "";
        }
        if (castling[us]) {
          for (var i = 0, len = ROOKS[us].length; i < len; i++) {
            if (move.from === ROOKS[us][i].square && castling[us] & ROOKS[us][i].flag) {
              castling[us] ^= ROOKS[us][i].flag;
              break;
            }
          }
        }
        if (castling[them]) {
          for (var i = 0, len = ROOKS[them].length; i < len; i++) {
            if (move.to === ROOKS[them][i].square && castling[them] & ROOKS[them][i].flag) {
              castling[them] ^= ROOKS[them][i].flag;
              break;
            }
          }
        }
        if (move.flags & BITS.BIG_PAWN) {
          if (turn === "b") {
            ep_square = move.to - 16;
          } else {
            ep_square = move.to + 16;
          }
        } else {
          ep_square = EMPTY;
        }
        if (move.piece === PAWN) {
          half_moves = 0;
        } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
          half_moves = 0;
        } else {
          half_moves++;
        }
        if (turn === BLACK) {
          move_number++;
        }
        turn = swap_color(turn);
      }
      function undo_move() {
        var old = history.pop();
        if (old == null) {
          return null;
        }
        var move = old.move;
        kings = old.kings;
        turn = old.turn;
        castling = old.castling;
        ep_square = old.ep_square;
        half_moves = old.half_moves;
        move_number = old.move_number;
        var us = turn;
        var them = swap_color(turn);
        board[move.from] = board[move.to];
        board[move.from].type = move.piece;
        board[move.to] = null;
        if (move.flags & BITS.CAPTURE) {
          board[move.to] = { type: move.captured, color: them };
        } else if (move.flags & BITS.EP_CAPTURE) {
          var index;
          if (us === BLACK) {
            index = move.to - 16;
          } else {
            index = move.to + 16;
          }
          board[index] = { type: PAWN, color: them };
        }
        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
          var castling_to, castling_from;
          if (move.flags & BITS.KSIDE_CASTLE) {
            castling_to = move.to + 1;
            castling_from = move.to - 1;
          } else if (move.flags & BITS.QSIDE_CASTLE) {
            castling_to = move.to - 2;
            castling_from = move.to + 1;
          }
          board[castling_to] = board[castling_from];
          board[castling_from] = null;
        }
        return move;
      }
      function get_disambiguator(move, sloppy) {
        var moves = generate_moves({ legal: !sloppy });
        var from = move.from;
        var to = move.to;
        var piece = move.piece;
        var ambiguities = 0;
        var same_rank = 0;
        var same_file = 0;
        for (var i = 0, len = moves.length; i < len; i++) {
          var ambig_from = moves[i].from;
          var ambig_to = moves[i].to;
          var ambig_piece = moves[i].piece;
          if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {
            ambiguities++;
            if (rank(from) === rank(ambig_from)) {
              same_rank++;
            }
            if (file(from) === file(ambig_from)) {
              same_file++;
            }
          }
        }
        if (ambiguities > 0) {
          if (same_rank > 0 && same_file > 0) {
            return algebraic(from);
          } else if (same_file > 0) {
            return algebraic(from).charAt(1);
          } else {
            return algebraic(from).charAt(0);
          }
        }
        return "";
      }
      function ascii() {
        var s = "   +------------------------+\n";
        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
          if (file(i) === 0) {
            s += " " + "87654321"[rank(i)] + " |";
          }
          if (board[i] == null) {
            s += " . ";
          } else {
            var piece = board[i].type;
            var color = board[i].color;
            var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
            s += " " + symbol + " ";
          }
          if (i + 1 & 136) {
            s += "|\n";
            i += 8;
          }
        }
        s += "   +------------------------+\n";
        s += "     a  b  c  d  e  f  g  h\n";
        return s;
      }
      function move_from_san(move, sloppy) {
        var clean_move = stripped_san(move);
        if (sloppy) {
          var matches = clean_move.match(
            /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/
          );
          if (matches) {
            var piece = matches[1];
            var from = matches[2];
            var to = matches[3];
            var promotion = matches[4];
          }
        }
        var moves = generate_moves();
        for (var i = 0, len = moves.length; i < len; i++) {
          if (clean_move === stripped_san(move_to_san(moves[i])) || sloppy && clean_move === stripped_san(move_to_san(moves[i], true))) {
            return moves[i];
          } else {
            if (matches && (!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[from] == moves[i].from && SQUARES[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {
              return moves[i];
            }
          }
        }
        return null;
      }
      function rank(i) {
        return i >> 4;
      }
      function file(i) {
        return i & 15;
      }
      function algebraic(i) {
        var f = file(i), r = rank(i);
        return "abcdefgh".substring(f, f + 1) + "87654321".substring(r, r + 1);
      }
      function swap_color(c) {
        return c === WHITE ? BLACK : WHITE;
      }
      function is_digit(c) {
        return "0123456789".indexOf(c) !== -1;
      }
      function make_pretty(ugly_move) {
        var move = clone(ugly_move);
        move.san = move_to_san(move, false);
        move.to = algebraic(move.to);
        move.from = algebraic(move.from);
        var flags = "";
        for (var flag in BITS) {
          if (BITS[flag] & move.flags) {
            flags += FLAGS[flag];
          }
        }
        move.flags = flags;
        return move;
      }
      function clone(obj) {
        var dupe = obj instanceof Array ? [] : {};
        for (var property in obj) {
          if (typeof property === "object") {
            dupe[property] = clone(obj[property]);
          } else {
            dupe[property] = obj[property];
          }
        }
        return dupe;
      }
      function trim(str) {
        return str.replace(/^\s+|\s+$/g, "");
      }
      function perft(depth) {
        var moves = generate_moves({ legal: false });
        var nodes = 0;
        var color = turn;
        for (var i = 0, len = moves.length; i < len; i++) {
          make_move(moves[i]);
          if (!king_attacked(color)) {
            if (depth - 1 > 0) {
              var child_nodes = perft(depth - 1);
              nodes += child_nodes;
            } else {
              nodes++;
            }
          }
          undo_move();
        }
        return nodes;
      }
      return {
        /***************************************************************************
         * PUBLIC CONSTANTS (is there a better way to do this?)
         **************************************************************************/
        WHITE,
        BLACK,
        PAWN,
        KNIGHT,
        BISHOP,
        ROOK,
        QUEEN,
        KING,
        SQUARES: function() {
          var keys = [];
          for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
            if (i & 136) {
              i += 7;
              continue;
            }
            keys.push(algebraic(i));
          }
          return keys;
        }(),
        FLAGS,
        /***************************************************************************
         * PUBLIC API
         **************************************************************************/
        load: function(fen2) {
          return load(fen2);
        },
        reset: function() {
          return reset();
        },
        moves: function(options) {
          var ugly_moves = generate_moves(options);
          var moves = [];
          for (var i = 0, len = ugly_moves.length; i < len; i++) {
            if (typeof options !== "undefined" && "verbose" in options && options.verbose) {
              moves.push(make_pretty(ugly_moves[i]));
            } else {
              moves.push(move_to_san(ugly_moves[i], false));
            }
          }
          return moves;
        },
        in_check: function() {
          return in_check();
        },
        in_checkmate: function() {
          return in_checkmate();
        },
        in_stalemate: function() {
          return in_stalemate();
        },
        in_draw: function() {
          return half_moves >= 100 || in_stalemate() || insufficient_material() || in_threefold_repetition();
        },
        insufficient_material: function() {
          return insufficient_material();
        },
        in_threefold_repetition: function() {
          return in_threefold_repetition();
        },
        game_over: function() {
          return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition();
        },
        validate_fen: function(fen2) {
          return validate_fen(fen2);
        },
        fen: function() {
          return generate_fen();
        },
        board: function() {
          var output = [], row = [];
          for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
            if (board[i] == null) {
              row.push(null);
            } else {
              row.push({ type: board[i].type, color: board[i].color });
            }
            if (i + 1 & 136) {
              output.push(row);
              row = [];
              i += 8;
            }
          }
          return output;
        },
        pgn: function(options) {
          var newline = typeof options === "object" && typeof options.newline_char === "string" ? options.newline_char : "\n";
          var max_width = typeof options === "object" && typeof options.max_width === "number" ? options.max_width : 0;
          var result = [];
          var header_exists = false;
          for (var i in header) {
            result.push("[" + i + ' "' + header[i] + '"]' + newline);
            header_exists = true;
          }
          if (header_exists && history.length) {
            result.push(newline);
          }
          var append_comment = function(move_string2) {
            var comment = comments[generate_fen()];
            if (typeof comment !== "undefined") {
              var delimiter = move_string2.length > 0 ? " " : "";
              move_string2 = `${move_string2}${delimiter}{${comment}}`;
            }
            return move_string2;
          };
          var reversed_history = [];
          while (history.length > 0) {
            reversed_history.push(undo_move());
          }
          var moves = [];
          var move_string = "";
          if (reversed_history.length === 0) {
            moves.push(append_comment(""));
          }
          while (reversed_history.length > 0) {
            move_string = append_comment(move_string);
            var move = reversed_history.pop();
            if (!history.length && move.color === "b") {
              move_string = move_number + ". ...";
            } else if (move.color === "w") {
              if (move_string.length) {
                moves.push(move_string);
              }
              move_string = move_number + ".";
            }
            move_string = move_string + " " + move_to_san(move, false);
            make_move(move);
          }
          if (move_string.length) {
            moves.push(append_comment(move_string));
          }
          if (typeof header.Result !== "undefined") {
            moves.push(header.Result);
          }
          if (max_width === 0) {
            return result.join("") + moves.join(" ");
          }
          var strip = function() {
            if (result.length > 0 && result[result.length - 1] === " ") {
              result.pop();
              return true;
            }
            return false;
          };
          var wrap_comment = function(width, move2) {
            for (var token of move2.split(" ")) {
              if (!token) {
                continue;
              }
              if (width + token.length > max_width) {
                while (strip()) {
                  width--;
                }
                result.push(newline);
                width = 0;
              }
              result.push(token);
              width += token.length;
              result.push(" ");
              width++;
            }
            if (strip()) {
              width--;
            }
            return width;
          };
          var current_width = 0;
          for (var i = 0; i < moves.length; i++) {
            if (current_width + moves[i].length > max_width) {
              if (moves[i].includes("{")) {
                current_width = wrap_comment(current_width, moves[i]);
                continue;
              }
            }
            if (current_width + moves[i].length > max_width && i !== 0) {
              if (result[result.length - 1] === " ") {
                result.pop();
              }
              result.push(newline);
              current_width = 0;
            } else if (i !== 0) {
              result.push(" ");
              current_width++;
            }
            result.push(moves[i]);
            current_width += moves[i].length;
          }
          return result.join("");
        },
        load_pgn: function(pgn, options) {
          var sloppy = typeof options !== "undefined" && "sloppy" in options ? options.sloppy : false;
          function mask(str) {
            return str.replace(/\\/g, "\\");
          }
          function has_keys(object) {
            for (var key2 in object) {
              return true;
            }
            return false;
          }
          function parse_pgn_header(header2, options2) {
            var newline_char2 = typeof options2 === "object" && typeof options2.newline_char === "string" ? options2.newline_char : "\r?\n";
            var header_obj = {};
            var headers2 = header2.split(new RegExp(mask(newline_char2)));
            var key2 = "";
            var value = "";
            for (var i = 0; i < headers2.length; i++) {
              key2 = headers2[i].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/, "$1");
              value = headers2[i].replace(/^\[[A-Za-z]+\s"(.*)"\ *\]$/, "$1");
              if (trim(key2).length > 0) {
                header_obj[key2] = value;
              }
            }
            return header_obj;
          }
          var newline_char = typeof options === "object" && typeof options.newline_char === "string" ? options.newline_char : "\r?\n";
          var header_regex = new RegExp(
            "^(\\[((?:" + mask(newline_char) + ")|.)*\\])(?:" + mask(newline_char) + "){2}"
          );
          var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : "";
          reset();
          var headers = parse_pgn_header(header_string, options);
          for (var key in headers) {
            set_header([key, headers[key]]);
          }
          if (headers["SetUp"] === "1") {
            if (!("FEN" in headers && load(headers["FEN"], true))) {
              return false;
            }
          }
          var to_hex = function(string) {
            return Array.from(string).map(function(c) {
              return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/\%/g, "").toLowerCase();
            }).join("");
          };
          var from_hex = function(string) {
            return string.length == 0 ? "" : decodeURIComponent("%" + string.match(/.{1,2}/g).join("%"));
          };
          var encode_comment = function(string) {
            string = string.replace(new RegExp(mask(newline_char), "g"), " ");
            return `{${to_hex(string.slice(1, string.length - 1))}}`;
          };
          var decode_comment = function(string) {
            if (string.startsWith("{") && string.endsWith("}")) {
              return from_hex(string.slice(1, string.length - 1));
            }
          };
          var ms = pgn.replace(header_string, "").replace(
            /* encode comments so they don't get deleted below */
            new RegExp(`({[^}]*})+?|;([^${mask(newline_char)}]*)`, "g"),
            function(match, bracket, semicolon) {
              return bracket !== void 0 ? encode_comment(bracket) : " " + encode_comment(`{${semicolon.slice(1)}}`);
            }
          ).replace(new RegExp(mask(newline_char), "g"), " ");
          var rav_regex = /(\([^\(\)]+\))+?/g;
          while (rav_regex.test(ms)) {
            ms = ms.replace(rav_regex, "");
          }
          ms = ms.replace(/\d+\.(\.\.)?/g, "");
          ms = ms.replace(/\.\.\./g, "");
          ms = ms.replace(/\$\d+/g, "");
          var moves = trim(ms).split(new RegExp(/\s+/));
          moves = moves.join(",").replace(/,,+/g, ",").split(",");
          var move = "";
          for (var half_move = 0; half_move < moves.length - 1; half_move++) {
            var comment = decode_comment(moves[half_move]);
            if (comment !== void 0) {
              comments[generate_fen()] = comment;
              continue;
            }
            move = move_from_san(moves[half_move], sloppy);
            if (move == null) {
              return false;
            } else {
              make_move(move);
            }
          }
          comment = decode_comment(moves[moves.length - 1]);
          if (comment !== void 0) {
            comments[generate_fen()] = comment;
            moves.pop();
          }
          move = moves[moves.length - 1];
          if (POSSIBLE_RESULTS.indexOf(move) > -1) {
            if (has_keys(header) && typeof header.Result === "undefined") {
              set_header(["Result", move]);
            }
          } else {
            move = move_from_san(move, sloppy);
            if (move == null) {
              return false;
            } else {
              make_move(move);
            }
          }
          return true;
        },
        header: function() {
          return set_header(arguments);
        },
        ascii: function() {
          return ascii();
        },
        turn: function() {
          return turn;
        },
        move: function(move, options) {
          var sloppy = typeof options !== "undefined" && "sloppy" in options ? options.sloppy : false;
          var move_obj = null;
          if (typeof move === "string") {
            move_obj = move_from_san(move, sloppy);
          } else if (typeof move === "object") {
            var moves = generate_moves();
            for (var i = 0, len = moves.length; i < len; i++) {
              if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!("promotion" in moves[i]) || move.promotion === moves[i].promotion)) {
                move_obj = moves[i];
                break;
              }
            }
          }
          if (!move_obj) {
            return null;
          }
          var pretty_move = make_pretty(move_obj);
          make_move(move_obj);
          return pretty_move;
        },
        undo: function() {
          var move = undo_move();
          return move ? make_pretty(move) : null;
        },
        clear: function() {
          return clear();
        },
        put: function(piece, square) {
          return put(piece, square);
        },
        get: function(square) {
          return get(square);
        },
        remove: function(square) {
          return remove(square);
        },
        perft: function(depth) {
          return perft(depth);
        },
        square_color: function(square) {
          if (square in SQUARES) {
            var sq_0x88 = SQUARES[square];
            return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? "light" : "dark";
          }
          return null;
        },
        history: function(options) {
          var reversed_history = [];
          var move_history = [];
          var verbose = typeof options !== "undefined" && "verbose" in options && options.verbose;
          while (history.length > 0) {
            reversed_history.push(undo_move());
          }
          while (reversed_history.length > 0) {
            var move = reversed_history.pop();
            if (verbose) {
              move_history.push(make_pretty(move));
            } else {
              move_history.push(move_to_san(move));
            }
            make_move(move);
          }
          return move_history;
        },
        get_comment: function() {
          return comments[generate_fen()];
        },
        set_comment: function(comment) {
          comments[generate_fen()] = comment.replace("{", "[").replace("}", "]");
        },
        delete_comment: function() {
          var comment = comments[generate_fen()];
          delete comments[generate_fen()];
          return comment;
        },
        get_comments: function() {
          prune_comments();
          return Object.keys(comments).map(function(fen2) {
            return { fen: fen2, comment: comments[fen2] };
          });
        },
        delete_comments: function() {
          prune_comments();
          return Object.keys(comments).map(function(fen2) {
            var comment = comments[fen2];
            delete comments[fen2];
            return { fen: fen2, comment };
          });
        }
      };
    };
    if (typeof exports !== "undefined")
      exports.Chess = Chess;
    if (typeof define !== "undefined")
      define(function() {
        return Chess;
      });
  }
});

// node_modules/chess-web-api/src/endpoints/games.js
var require_games = __commonJS({
  "node_modules/chess-web-api/src/endpoints/games.js"(exports, module) {
    var { Chess } = require_chess();
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    var WebApiError = require_webapi_error();
    var { sortParameters } = require_sort_parameters();
    var BOARD_POSITIONS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!?";
    var BOARD_FILES = "abcdefgh";
    var BOARD_LENGTH = 8;
    var PROMOTION_TABLE = "#@$_[]^()~{}";
    var PROMOTION_TABLE_ROWS = "brnq";
    var PROMOTION_TABLE_ROWS_LENGTH = 4;
    var PROMOTION_TABLE_COLUMNS_LENGTH = 3;
    var PROMOTION_CAPTURE_LEFT = 1;
    var PROMOTION_CAPTURE_RIGHT = 2;
    var UNDOCUMENTED_API_HOST = "chess.com";
    var ERR_MISSING_OR_EMPTY = "Result missing or empty.";
    function _PawnPromotion(index) {
      const pieceIndex = Math.floor(index / PROMOTION_TABLE_COLUMNS_LENGTH);
      if (pieceIndex > PROMOTION_TABLE_ROWS_LENGTH - 1) {
        throw new Error(`Pawn promotion row index out of bounds: ${pieceIndex}`);
      }
      this.piece = PROMOTION_TABLE_ROWS[pieceIndex];
      this.isCaptureLeft = index % PROMOTION_TABLE_COLUMNS_LENGTH === PROMOTION_CAPTURE_LEFT;
      this.isCaptureRight = index % PROMOTION_TABLE_COLUMNS_LENGTH === PROMOTION_CAPTURE_RIGHT;
    }
    _PawnPromotion.prototype.getTo = function(from) {
      const fromFile = from[0];
      const fromRank = from[1];
      const fromFileIndex = BOARD_FILES.indexOf(fromFile);
      let toFileIndex;
      if (this.isCaptureLeft) {
        toFileIndex = fromFileIndex - 1;
      } else {
        toFileIndex = this.isCaptureRight ? fromFileIndex + 1 : fromFileIndex;
      }
      if (toFileIndex < 0 || toFileIndex > BOARD_LENGTH - 1) {
        throw new Error(`Invalid pawn promotion; file index out of bounds: ${toFileIndex}`);
      }
      const toFile = BOARD_FILES[toFileIndex];
      let toRank;
      if (fromRank === "2") {
        toRank = "1";
      } else if (fromRank === "7") {
        toRank = "8";
      } else {
        throw new Error(`Invalid rank prior to pawn promotion: ${fromRank}`);
      }
      return `${toFile}${toRank}`;
    };
    function _decodeMove(encMove, isTo) {
      const index = BOARD_POSITIONS.indexOf(encMove);
      if (index === -1) {
        if (isTo) {
          const promotionIndex = PROMOTION_TABLE.indexOf(encMove);
          if (promotionIndex !== -1) {
            return new _PawnPromotion(promotionIndex);
          }
        }
        throw new Error(`Unrecognized move-character: ${encMove}`);
      }
      const file = BOARD_FILES[index % BOARD_LENGTH];
      const rank = Math.floor(index / BOARD_LENGTH) + 1;
      return `${file}${rank}`;
    }
    function _getPGN(pgnHeaders, moveList) {
      const moveListLength = moveList.length;
      if (moveListLength === 0 || moveListLength % 2 !== 0) {
        throw new Error(`Malformed field "game.moveList"; expected non-empty, even-number of characters: ${moveList}`);
      }
      const chess = "FEN" in pgnHeaders ? new Chess(pgnHeaders.FEN) : new Chess();
      Object.keys(pgnHeaders).forEach((key) => {
        chess.header(key, pgnHeaders[key]);
      });
      for (let i = 0; i < moveListLength; i += 2) {
        const move = {
          from: _decodeMove(moveList[i], false),
          to: _decodeMove(moveList[i + 1], true)
        };
        if (move.to instanceof _PawnPromotion) {
          move.promotion = move.to.piece;
          move.to = move.to.getTo(move.from);
        }
        chess.move(move);
      }
      return chess.pgn();
    }
    function _getRequiredProperty(obj, propName, fullName) {
      if (Object.prototype.hasOwnProperty.call(obj, propName)) {
        return obj[propName];
      }
      const fieldName = typeof fullName !== "undefined" ? fullName : propName;
      throw new Error(`Missing required field "${fieldName}"`);
    }
    function _modifyResultBody(resultBody) {
      const game = _getRequiredProperty(resultBody, "game");
      const moveList = _getRequiredProperty(game, "moveList", "game.moveList");
      const pgnHeaders = _getRequiredProperty(game, "pgnHeaders", "game.pgnHeaders");
      game.pgn = _getPGN(pgnHeaders, moveList);
    }
    function getGameByID(id, options, callback, headers) {
      const [_options, _callback, _headers] = sortParameters(
        ["object", "function", "object"],
        [options, callback, headers]
      );
      const apiRequest = WebApiRequest.builder().withHost(UNDOCUMENTED_API_HOST).withPath(`/callback/live/game/${id}`).withQueryParameters(_options).withHeaders(_headers).build();
      if (_callback) {
        HttpManager.get(apiRequest, (error, result) => {
          if (error) {
            _callback(error);
          } else if (!result || !Object.prototype.hasOwnProperty.call(result, "body")) {
            _callback(new WebApiError(ERR_MISSING_OR_EMPTY));
          } else {
            try {
              _modifyResultBody(result.body);
              _callback(null, result);
            } catch (e) {
              _callback(e);
            }
          }
        });
        return null;
      }
      return new Promise((resolve, reject) => {
        HttpManager.get(apiRequest, (error, result) => {
          if (error) {
            reject(error);
          } else if (!result || !Object.prototype.hasOwnProperty.call(result, "body")) {
            reject(new WebApiError(ERR_MISSING_OR_EMPTY));
          } else {
            try {
              _modifyResultBody(result.body);
              resolve(result);
            } catch (e) {
              reject(e);
            }
          }
        });
      });
    }
    module.exports = {
      getGameByID
    };
  }
});

// node_modules/chess-web-api/src/chess-web-api.js
var require_chess_web_api = __commonJS({
  "node_modules/chess-web-api/src/chess-web-api.js"(exports, module) {
    var Queue = require_queue();
    var {
      getPlayer,
      getPlayerStats,
      getPlayerOnline,
      getPlayerCurrentDailyChess,
      getPlayerToMoveDailyChess,
      getPlayerMonthlyArchives,
      getPlayerCompleteMonthlyArchives,
      getPlayerMultiGamePGN,
      getPlayerClubs,
      getPlayerMatches,
      getPlayerTournaments,
      getTitledPlayers
    } = require_player_data();
    var {
      getClub,
      getClubMembers,
      getClubMatches
    } = require_clubs();
    var {
      getTournament,
      getTournamentRound,
      getTournamentRoundGroup
    } = require_tournaments();
    var {
      getTeamMatch,
      getTeamMatchBoard,
      getTeamLiveMatch,
      getTeamLiveMatchBoard
    } = require_team_matches();
    var {
      getCountry,
      getCountryPlayers,
      getCountryClubs
    } = require_countries();
    var {
      getDailyPuzzle,
      getDailyPuzzleRandom
    } = require_puzzles();
    var {
      getStreamers
    } = require_streamers();
    var {
      getLeaderboards
    } = require_leaderboards();
    var {
      getGameByID
    } = require_games();
    function ChessWebAPI(options) {
      if (options && "queue" in options && options.queue) {
        this.addMethods(Queue);
        this.queueSetup();
      }
    }
    ChessWebAPI.prototype = {
      addMethods(methods) {
        const queueMethods = Object.keys(methods);
        for (let i = 0; i < queueMethods.length; i += 1) {
          this[queueMethods[i]] = methods[queueMethods[i]];
        }
      },
      async ifChanged(etag, method, parameters, options, callback) {
        if (!etag || typeof etag !== "string") {
          throw Error("etag required for ifChanged");
        }
        if (!method || typeof method !== "function") {
          throw Error("dispatch requires request function");
        }
        let actualParameters = [];
        let actualCallback = null;
        let actualOptions = {};
        const items = [parameters, options, callback];
        for (let i = 0; i < items.length; i += 1) {
          if (items[i]) {
            if (items[i] instanceof Array) {
              actualParameters = items[i];
            } else if (typeof items[i] === "object") {
              actualOptions = items[i];
            } else if (typeof items[i] === "function") {
              actualCallback = items[i];
            }
          }
        }
        try {
          const data = await method(
            ...actualParameters,
            actualOptions,
            actualCallback,
            {
              "If-None-Match": etag
            }
          );
          const response = {
            changed: true,
            response: data
          };
          return response;
        } catch (error) {
          return { changed: false };
        }
      },
      getPlayer,
      getPlayerStats,
      getPlayerOnline,
      getPlayerCurrentDailyChess,
      getPlayerToMoveDailyChess,
      getPlayerMonthlyArchives,
      getPlayerCompleteMonthlyArchives,
      getPlayerMultiGamePGN,
      getPlayerClubs,
      getPlayerMatches,
      getPlayerTournaments,
      getTitledPlayers,
      getClub,
      getClubMembers,
      getClubMatches,
      getTournament,
      getTournamentRound,
      getTournamentRoundGroup,
      getTeamMatch,
      getTeamMatchBoard,
      getTeamLiveMatch,
      getTeamLiveMatchBoard,
      getCountry,
      getCountryPlayers,
      getCountryClubs,
      getDailyPuzzle,
      getDailyPuzzleRandom,
      getStreamers,
      getLeaderboards,
      getGameByID
    };
    module.exports = ChessWebAPI;
  }
});

// node_modules/chess-web-api/src/index.js
var require_src = __commonJS({
  "node_modules/chess-web-api/src/index.js"(exports, module) {
    var ChessWebAPI = require_chess_web_api();
    module.exports = ChessWebAPI;
  }
});
export default require_src();
//# sourceMappingURL=chess-web-api.js.map
